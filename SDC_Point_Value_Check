--분자--
① Spec_GR 테이블에서 모델에 해당하는 Spec_Group_Id 를 찾음 
② 분자코드(Numerator_calc_Method_Code)를 확인한다.(G/P/D/F)
※ 단, 분자가 F인 경우 오류코드값( TB_EDC_SDC2_INSP_DATA 테이블의 정보)을 반영하며
   , 나머지 조건에서는 오류코드 사용하지 않음(나중에 오류코드 계산방법만 추가 알아볼 것)
   
	▶ 분자코드 확인 전에 그룹단위 확인이 우선되어야 하며, 이부분에 대한 설명 빠졌음..
	   - 그룹단위가 LOT단위인 경우 Numerator_Calc_Method_Code 에 해당하는 부분의 판정값들 중에서 불량코드 기준정보테이블에서 SPEC_GR_ID에
	   해당하는 판정값만 카운팅하면 된다.
	   또한 전일 23시 부터 당일 23시까지 그룹단위별로 "CHECK_RANK_VALUE : 날짜_몇번째 포인트"가 매겨짐(자세한 방법은 해당일 노트참조)

③ Judge_Cond 테이블에서 ①과 동일한 Spec_Group_Id 를 찾음
※ 단, JUDGE_COND 테이블에서 해당 SPEC_GR_ID가 조회되지 않을 경우, Spec_GR 테이블에서 분자코드(Numerator_calc_Method_Code)에 해당하는
   DefectFile Section의 모든 판정값을 데이터로 사용함.
   Ex) Numerator_Calc_Method_Code가 D이면 Defect_Info의 Judge를 대상 판정값으로 사용
       단, 카운팅 대상은 ⑥의 Inspection_Step_Code 컬럼값에 한함.
④ ②에서 분자코드가 존재 할 경우 ③에서 Numerator_Flag가 'Y' 인 것을 확인하고
   , Judgement_Type_Code가 ②에서 확인한 분자코드(G/P, D는 추가예정)와 일치하는 것을 찾은 후
   , 해당 Judgement_Code 컬럼의 코드값과 Inspection_Step_Code 컬럼의 값(Latest, Review, Repair / Null일경우 Latest)을 확인한다.
⑤ ④의 Judment_Type_Code (Glass/Panel/Defect)부분에서 Inspection_Step_Code 컬럼의 값(Latest/Review/epair)에 해당하는 부분 중
   , Judgement_Code와 동일한 코드값을 DefectFile에서 조회한다.
※ JUDGEMENT_CODE는 분자/분모 모두의 판정값으로 쓰인다는 점
⑥ TB_EDC_SDC2_DEF_COND 테이블에서 대상 SPEC_GR_ID를 조회하고, ⑤의 결과에서 Inspection_Step_Code 컬럼의 값과 일치하는 불량코드를 조회한 후
   해당 불량코드를 가진 판정값만 카운팅하여 분자값으로 최종 반영한다.
※ 부연 : ⑤의 조회된 데이터중 TB_EDC_SDC2_DEF_COND 테이블에 있는 불량코드와 유사한 ( LIKE ) 코드값만 카운팅
		- 로그프레소에서는 아래 기준정보테이블(불량코드)과 비교코드를 미리 LIKE조인하여 룩업에 올림
		※쿼리
		SELECT * FROM TB_EDC_DEF_CD G
		 WHERE G.FULL_DEFECT_CODE LIKE 'A0G-B0B-C0T-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-Y05-%-%-%-%-%-%-%-%-%-%-%'
			or G.FULL_DEFECT_CODE LIKE 'A0G-B0D-C0T-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-Y05-%-%-%-%-%-%-%-%-%-%-%' 
⑦ 7-1) INSPECTION_PROCESS_CODE가 프로세스 넘버일 경우
   분자계산 끝? (그룹단위가 P가 아닌 L일 경우 빠졌음)
   7-2) INSPECTION_PROCESS_CODE가 프로세스 넘버가 아닐경우
   TB_EDC_SDC2_SPEC 테이블에서 INSPECTION_PROCESS_CODE가 프로세스 넘버가 아닐경우 둘 이상의 프로세스가 묶여서 참조된 값으로
   , 해당 참조값을 별도로 조회해서 검사공정 프로세스가 무엇인지 파악해야 한다.
   ex) 참조값 : 'S3'
   ※쿼리
   select * from TB_EDC_SDC2_INSP_PROC_GROUP_N a
    where a.facility_code = 'P9T'
      and a.inspection_process_group_id = 'S3';
⑧ 7-2)의 경우 쿼리를 조회하면 '5860','6047','6175' 검사공정 프로세스가 나오며
   , 동일한 GLASS_ID에 대해 세개 검사공정에서 각각 올라온 DefectFile을 통해 계산된 SDC_POINT VALUE값을 DB의 POINT_DATA 테이블에 넣는다.
⑨ 또한, ⑧의 세개의 검사공정 프로세스에서 각각 Defect 정보를 통해 계산된 SDC_POINT VALUE값을 더해서 POINT 테이블에 순차적으로 UPDATE한다.
   (처음 값은 INSERT)


--분모--
① -분자-①의 Spec_Group_Id에서 분모코드(Denominator_Calc_Method_Code)값 확인(G/P/N)
② Judge_Cond 테이블에서 ①과 동일한 Spec_Group_Id 를 찾음
③ ①에서 분모코드가 'N'이 아닐경우 ②에서 Numerator_Flag가 'N' 인 것을 확인하고
   , Judgement_Type_Code가 -분자-②에서 확인한 분자코드(G/P/D)와 일치하는 것을 찾은 후
   , 해당 Judgement_Code 컬럼의 코드값중 ①의 분모코드와 일치하는 것을 찾고
   , Inspection_Step_Code 컬럼의 값(Latest, Review, Repair / Null일경우 Latest)을 확인한다.
 - 'N'일 경우 N/A로 분모계산은 하지 않는다.
※ 단, Judge_Cond 테이블에서 분모에 해당(Numerator_Flag가 'N')하는 판정이 없다면 판정값에 상관없이 검사가 된 데이터는 모두 분모로 사용하겠다는 것을 의미한다.
   [질문!] LATEST_JUDGEMENT_CODE, REVIEW_JUDGEMENT_CODE , REPAIR_JUDGEMENT_CODE 상관없이 모두를 카운팅 하면 되는건지요
		   아니면, 분자-③-Ex 의 내용처럼 분자와 같은 Inspection_Step_Code 컬럼값의 Judge만 카운팅하면 될까요.
④ DefectFile에서 ③의 Judment_Type_Code (Glass/Panel/Defect)와 Inspection_Step_Code 컬럼의 값(Latest/Review/epair)에 해당하는 부분 중
   , Judgement_Code와 동일한 코드값을 카운팅한다
⑤ ④를 분모값으로 반영한다.





--마지막 내용--
TB_EDC_SDC2_SPEC 테이블에서 INSPECTION_PROCESS_CODE가 숨겨져(EX : 'S3') 있을경우
다음 테이블을 참조하여 해당 검사프로세스를 참조한다.

/* 검사설비 조회 쿼리 */
select * from TB_EDC_SDC2_INSP_PROC_GROUP_N a
 where a.facility_code = 'P9T'
   and a.inspection_process_group_id = 'S3'

동일한 글래스가 각 프로세스별로 시간을 두고 DefectFile이 올라오는대로
POINT_DATA테이블에 각각 APPEND 시키고
마지막 공정에서의 DefectFile이 올라오면
'S3'에 해당하는 프로세스로 부터 각각 계산된 판정값들을 모두 합치고,
최종적으로 분모를 계산하여 나눈값을(분모코드가 N이 아닐경우)
POINT 테이블에 UPDATE 한다.
